# 统一版本控制机制设计方案（WebFlux优化版）

## 1. 问题分析

### 1.1 当前版本控制问题
- **乐观锁版本号管理混乱**：TestDataFactory中版本号初始化不一致
- **测试数据版本冲突**：缓存机制导致相同对象实例被重复使用
- **版本概念混淆**：R2DBC版本号、应用版本号、构建版本号概念不清晰
- **测试隔离不足**：批量操作测试中版本号冲突频发

### 1.2 影响范围
- 所有继承 `AuditableEntity` 的实体类（22个实体）
- 测试数据工厂 `TestDataFactory`
- 乐观锁机制的正确性
- 自动化测试的稳定性

## 2. 统一版本控制策略

### 2.1 版本号分类定义

#### 2.1.1 R2DBC乐观锁版本号（Entity Version）
- **用途**：数据库乐观锁控制
- **注解**：`@Version`
- **类型**：`Long`
- **管理方式**：R2DBC自动管理
- **初始值**：`null`（新实体）或数据库当前值（已存在实体）

#### 2.1.2 应用版本号（Application Version）
- **用途**：代码文档版本标识
- **格式**：`@version x.y.z`
- **管理方式**：手动维护
- **用途**：JavaDoc注释中的版本信息

#### 2.1.3 构建版本号（Build Version）
- **用途**：应用构建版本标识
- **格式**：`x.y.z-buildNumber`（buildNumber为8位数字格式YYYYMMDD）
- **管理方式**：构建系统自动生成
- **存储**：`build-version.properties`
- **管理工具**：`BuildVersionManager`类

#### 2.1.4 系统版本信息（System Version）
- **用途**：系统功能版本管理
- **实体**：`VersionInfo`、`VersionChangeLog`、`BuildVersion`
- **管理方式**：业务逻辑控制
- **管理工具**：`VersionManager`类

### 2.2 统一版本管理原则

#### 2.2.1 R2DBC版本号管理原则
1. **新实体创建**：版本号设置为 `null`，由R2DBC自动初始化为0
2. **实体更新**：版本号由R2DBC自动递增
3. **测试数据**：统一使用 `null` 初始化，避免手动设置
4. **批量操作**：确保每个实体实例独立，避免版本冲突

#### 2.2.2 测试数据版本管理原则
1. **数据隔离**：每个测试使用独立的实体实例
2. **版本初始化**：统一设置为 `null`
3. **缓存控制**：对于频繁使用的测试数据使用缓存，但确保版本号重置
4. **清理机制**：测试后清理版本相关状态和缓存

## 3. 实现方案

### 3.1 TestDataFactory优化（基于实际实现）

#### 3.1.1 版本号统一初始化
```java
/**
 * 创建测试用户（示例）
 */
public static User createTestUser() {
    String cacheKey = "TEST_USER_DEFAULT";
    return getOrCreate(cacheKey, () -> {
        User template = (User) DATA_TEMPLATES.get("USER_TEMPLATE");
        User user = cloneUser(template);
        user.setUsername("testUser" + System.currentTimeMillis());
        user.setPassword("encoded-password");
        user.setRealName("测试用户");
        user.setEmail("test@example.com");
        user.setPhone("13800138000");
        user.setUserType(UserType.NORMAL_USER);
        user.setVersion(null); // 统一版本控制：设置为null，由R2DBC自动管理乐观锁版本号
        return user;
    });
}
```

#### 3.1.2 测试数据缓存与清理机制
```java
/**
 * 从缓存获取或创建数据
 */
private static <T> T getOrCreate(String key, java.util.function.Supplier<T> supplier) {
    return (T) DATA_CACHE.computeIfAbsent(key, k -> {
        T data = supplier.get();
        CLEANUP_KEYS.add(key);
        return data;
    });
}

/**
 * 执行选择性清理：根据标志仅清理指定类型的测试数据
 */
public static void cleanupCreatedData(DatabaseClient databaseClient, boolean cleanUsers, boolean cleanPermissions) {
    TestDataCleaner.cleanupSelective(databaseClient, cleanUsers, cleanPermissions);
}
```

### 3.2 响应式版本管理工具类

#### 3.2.1 VersionManager（响应式实现）
```java
/**
 * 版本管理器 - 响应式实现
 */
@Component
public class VersionManager {
    
    /**
     * 生成新的编译版本号
     */
    public Mono<String> generateBuildVersion() {
        LoggingUtil.debug(logger, "生成新的编译版本号");

        return Mono.fromCallable(() -> {
            String buildVersion = LocalDateTime.now().format(BUILD_VERSION_FORMAT);
            LoggingUtil.info(logger, "生成编译版本号: {}", buildVersion);
            return buildVersion;
        })
        .doOnError(error -> LoggingUtil.error(logger, "生成编译版本号失败", error));
    }
    
    /**
     * 创建新版本信息
     */
    public Mono<VersionInfo> createVersion(int majorVersion, int minorVersion, int patchVersion) {
        LoggingUtil.info(logger, "创建新版本信息: {}.{}.{}", majorVersion, minorVersion, patchVersion);

        return generateBuildVersion()
                .map(buildVersion -> {
                    VersionInfo versionInfo = new VersionInfo();
                    versionInfo.setMajorVersion(majorVersion);
                    versionInfo.setMinorVersion(minorVersion);
                    versionInfo.setPatchVersion(patchVersion);
                    versionInfo.setBuildVersion(buildVersion);
                    versionInfo.setReleaseVersion(String.format("%d.%d.%d", majorVersion, minorVersion, patchVersion));
                    versionInfo.setFullVersion(String.format("%d.%d.%d-%s", majorVersion, minorVersion, patchVersion, buildVersion));
                    versionInfo.setCreateTime(LocalDateTime.now());

                    LoggingUtil.info(logger, "创建版本信息成功: {}", versionInfo.getFullVersion());
                    return versionInfo;
                })
                .doOnError(error -> LoggingUtil.error(logger, "创建版本信息失败", error));
    }
}
```

### 3.3 Repository层版本处理（WebFlux最佳实践）

#### 3.3.1 响应式Repository接口设计
```java
/**
 * 响应式Repository接口示例
 */
public interface ReactiveUserRepository extends ReactiveCrudRepository<User, Long> {
    // R2DBC自动处理版本控制，无需额外实现
    // 版本号通过@Version注解自动管理
}
```

### 3.4 Service层版本管理

#### 3.4.1 响应式乐观锁异常处理
```java
/**
 * 响应式服务基类 - 版本控制支持
 */
public abstract class ReactiveBaseService {
    
    /**
     * 统一乐观锁异常处理（响应式）
     */
    protected <T> Mono<T> handleOptimisticLocking(Mono<T> operation) {
        return operation
            .onErrorResume(OptimisticLockingFailureException.class, 
                ex -> {
                    LoggingUtil.warn(logger, "乐观锁冲突: {}", ex.getMessage());
                    return Mono.error(new BusinessException(ErrorCode.OPTIMISTIC_LOCK_FAILURE, 
                        "数据已被其他用户修改，请刷新后重试"));
                });
    }
    
    /**
     * 批量操作中的版本控制处理（响应式）
     */
    protected <T extends AuditableEntity> Flux<T> ensureVersionControl(Flux<T> entities) {
        return entities.doOnNext(entity -> {
            if (entity.getId() == null) {
                entity.setVersion(null); // 新实体版本号设为null
            }
        });
    }
}
```

### 3.5 测试环境版本管理

#### 3.5.1 测试基类版本控制
```java
/**
 * WebFlux测试基类，提供统一版本管理
 */
@TestMethodOrder(OrderAnnotation.class)
public abstract class BaseWebFluxTest {
    
    @Autowired
    protected DatabaseClient databaseClient;
    
    /**
     * 创建测试实体，统一版本初始化
     */
    protected <T extends AuditableEntity> T createTestEntity(Supplier<T> entitySupplier) {
        T entity = entitySupplier.get();
        entity.setVersion(null); // 确保版本号为null
        return entity;
    }
    
    /**
     * 验证版本号正确性（响应式）
     */
    protected <T extends AuditableEntity> Mono<Boolean> assertVersionCorrect(Mono<T> entityMono, Long expectedVersion) {
        return entityMono.map(entity -> {
            Assertions.assertThat(entity.getVersion()).isEqualTo(expectedVersion);
            return true;
        });
    }
    
    /**
     * 测试后清理数据
     */
    @AfterEach
    protected void cleanupTestData() {
        TestDataFactory.cleanupCreatedData(databaseClient, true, true);
    }
}
```

## 4. 实施计划

### 4.1 第一阶段：TestDataFactory优化（已完成）
1. 统一版本号初始化设置为null
2. 优化缓存机制，确保版本号正确处理
3. 完善测试数据清理策略

### 4.2 第二阶段：版本管理工具完善
1. 完善VersionManager的响应式实现
2. 优化BuildVersionManager的8位版本号管理
3. 实现版本恢复和兼容性检查功能

### 4.3 第三阶段：Service层改进
1. 统一版本管理策略和异常处理
2. 优化响应式数据流中的版本控制
3. 完善批量操作的版本隔离机制

### 4.4 第四阶段：测试环境完善
1. 创建响应式测试基类
2. 统一测试数据管理和验证
3. 完善并发测试场景的版本控制验证

## 5. 验证标准

### 5.1 功能验证
- [x] 所有实体版本号正确初始化为null
- [x] 乐观锁机制正常工作
- [ ] 批量操作无版本冲突
- [x] 测试数据隔离正确

### 5.2 性能验证
- [ ] 版本管理不影响响应式性能
- [ ] 缓存机制优化有效
- [ ] 数据库操作效率保持

### 5.3 稳定性验证
- [ ] 所有测试通过
- [ ] 并发操作无版本冲突
- [ ] 异常处理机制完善

## 6. WebFlux最佳实践

### 6.1 响应式版本控制规范
1. 新实体创建时版本号设置为 `null`，由R2DBC自动管理
2. 更新实体时不手动修改版本号
3. 测试中使用独立实体实例并显式设置version为null
4. 批量操作使用Flux流处理，确保每个实体独立

### 6.2 响应式测试规范
1. 使用 `TestDataFactory` 创建测试数据，确保版本号正确初始化
2. 使用 `StepVerifier` 验证版本号正确性
3. 测试后清理版本状态和缓存数据
4. 并发测试使用 `StepVerifier.withVirtualTime()` 模拟并发场景

### 6.3 异常处理规范
1. 使用 `onErrorResume` 处理乐观锁异常
2. 提供用户友好的错误信息
3. 使用 `LoggingUtil` 记录版本冲突日志
4. 支持重试机制，使用 `retry()` 操作符

### 6.4 响应式数据流版本控制
1. 在数据流中使用 `doOnNext` 设置版本属性
2. 使用 `flatMap` 确保每个实体独立处理
3. 使用 `zip` 合并多个版本相关的操作
4. 避免在响应式流中阻塞操作，保持非阻塞特性

---

**作者**: Mr.Rey Copyright © 2025  
**创建时间**: 2025-07-01 10:30:00  
**版本**: 1.0.0 - 统一版本控制机制设计方案

